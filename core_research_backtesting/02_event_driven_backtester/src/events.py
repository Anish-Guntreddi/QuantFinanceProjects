"""
Event-driven backtester core event system.

This module defines all event types used in the event-driven backtesting framework.
Events are the fundamental communication mechanism between different components.
"""

import heapq
from enum import Enum
from dataclasses import dataclass, field
from datetime import datetime
from typing import Optional, Dict, Any, List
from abc import ABC, abstractmethod
import logging

logger = logging.getLogger(__name__)


class EventType(Enum):
    """Enumeration of all event types in the system."""
    MARKET = "MARKET"
    SIGNAL = "SIGNAL"
    ORDER = "ORDER"
    FILL = "FILL"
    RISK = "RISK"


@dataclass
class Event(ABC):
    """Base event class for all events in the system."""
    event_type: EventType
    timestamp: datetime
    priority: int = field(default=0)
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def __lt__(self, other):
        """Compare events for priority queue ordering."""
        if self.timestamp != other.timestamp:
            return self.timestamp < other.timestamp
        return self.priority < other.priority


@dataclass
class MarketEvent(Event):
    """Market data update event containing OHLCV and order book information."""
    symbol: str
    bid: Optional[float] = None
    ask: Optional[float] = None
    bid_size: Optional[float] = None
    ask_size: Optional[float] = None
    last: Optional[float] = None
    volume: Optional[float] = None
    open: Optional[float] = None
    high: Optional[float] = None
    low: Optional[float] = None
    close: Optional[float] = None
    vwap: Optional[float] = None
    
    def __post_init__(self):
        """Initialize event type and validate data."""
        object.__setattr__(self, 'event_type', EventType.MARKET)
        
        # Calculate mid price if bid/ask available
        if self.bid is not None and self.ask is not None:
            if 'mid_price' not in self.metadata:
                self.metadata['mid_price'] = (self.bid + self.ask) / 2
                
        # Calculate spread
        if self.bid is not None and self.ask is not None:
            if 'spread' not in self.metadata:
                self.metadata['spread'] = self.ask - self.bid
                
        logger.debug(f"Market event created for {self.symbol} at {self.timestamp}")

    @property
    def mid_price(self) -> Optional[float]:
        """Get the mid price (bid+ask)/2."""
        return self.metadata.get('mid_price')
    
    @property
    def spread(self) -> Optional[float]:
        """Get the bid-ask spread."""
        return self.metadata.get('spread')


@dataclass
class SignalEvent(Event):
    """Trading signal event generated by strategies."""
    symbol: str
    signal_type: str  # 'LONG', 'SHORT', 'EXIT'
    strength: float  # Signal strength from -1 (strong short) to 1 (strong long)
    target_position: Optional[float] = None
    target_weight: Optional[float] = None
    confidence: float = 1.0
    strategy_id: Optional[str] = None
    signal_metadata: Dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self):
        """Initialize event type and validate signal."""
        object.__setattr__(self, 'event_type', EventType.SIGNAL)
        
        # Validate signal strength
        if not -1 <= self.strength <= 1:
            raise ValueError(f"Signal strength must be between -1 and 1, got {self.strength}")
            
        # Validate confidence
        if not 0 <= self.confidence <= 1:
            raise ValueError(f"Confidence must be between 0 and 1, got {self.confidence}")
            
        logger.debug(f"Signal event created for {self.symbol}: {self.signal_type} "
                    f"(strength: {self.strength:.2f})")


@dataclass
class OrderEvent(Event):
    """Order placement event containing order details."""
    symbol: str
    order_type: str  # 'MARKET', 'LIMIT', 'STOP', 'STOP_LIMIT'
    quantity: float
    direction: str  # 'BUY', 'SELL'
    price: Optional[float] = None
    stop_price: Optional[float] = None
    time_in_force: str = 'DAY'  # 'DAY', 'GTC', 'IOC', 'FOK'
    order_id: Optional[str] = None
    parent_order_id: Optional[str] = None
    strategy_id: Optional[str] = None
    
    def __post_init__(self):
        """Initialize event type and validate order."""
        object.__setattr__(self, 'event_type', EventType.ORDER)
        
        # Generate order ID if not provided
        if self.order_id is None:
            import uuid
            object.__setattr__(self, 'order_id', str(uuid.uuid4()))
            
        # Validate quantity
        if self.quantity <= 0:
            raise ValueError(f"Order quantity must be positive, got {self.quantity}")
            
        # Validate order type specific requirements
        if self.order_type == 'LIMIT' and self.price is None:
            raise ValueError("Limit orders must specify a price")
            
        if self.order_type == 'STOP' and self.stop_price is None:
            raise ValueError("Stop orders must specify a stop price")
            
        if self.order_type == 'STOP_LIMIT':
            if self.price is None or self.stop_price is None:
                raise ValueError("Stop limit orders must specify both price and stop price")
                
        logger.debug(f"Order event created for {self.symbol}: {self.direction} "
                    f"{self.quantity} @ {self.order_type}")

    @property
    def notional_value(self) -> Optional[float]:
        """Calculate notional value of the order."""
        if self.price is not None:
            return abs(self.quantity * self.price)
        return None


@dataclass
class FillEvent(Event):
    """Order execution/fill event containing execution details."""
    symbol: str
    order_id: str
    quantity: float  # Filled quantity (signed: positive for buy, negative for sell)
    fill_price: float
    fill_time: Optional[datetime] = None
    commission: float = 0.0
    slippage: float = 0.0
    market_impact: float = 0.0
    execution_venue: Optional[str] = None
    liquidity_flag: Optional[str] = None  # 'ADDED', 'REMOVED'
    
    def __post_init__(self):
        """Initialize event type and calculate derived fields."""
        object.__setattr__(self, 'event_type', EventType.FILL)
        
        if self.fill_time is None:
            object.__setattr__(self, 'fill_time', self.timestamp)
            
        # Calculate total execution cost
        notional = abs(self.quantity * self.fill_price)
        total_cost = self.commission + abs(self.slippage) + abs(self.market_impact)
        self.metadata['execution_cost'] = total_cost
        self.metadata['execution_cost_bps'] = (total_cost / notional * 10000) if notional > 0 else 0
        
        logger.debug(f"Fill event created for {self.symbol}: {self.quantity} "
                    f"@ {self.fill_price:.4f} (cost: {self.metadata['execution_cost_bps']:.1f}bps)")

    @property
    def notional_value(self) -> float:
        """Calculate notional value of the fill."""
        return abs(self.quantity * self.fill_price)
    
    @property
    def total_cost(self) -> float:
        """Get total execution cost."""
        return self.metadata.get('execution_cost', 0.0)
    
    @property
    def cost_bps(self) -> float:
        """Get execution cost in basis points."""
        return self.metadata.get('execution_cost_bps', 0.0)


@dataclass
class RiskEvent(Event):
    """Risk management event for position limits and controls."""
    risk_type: str  # 'POSITION_LIMIT', 'DRAWDOWN_LIMIT', 'VAR_LIMIT', etc.
    severity: str  # 'INFO', 'WARNING', 'ERROR', 'CRITICAL'
    message: str
    current_value: Optional[float] = None
    limit_value: Optional[float] = None
    action_required: bool = False
    
    def __post_init__(self):
        """Initialize event type."""
        object.__setattr__(self, 'event_type', EventType.RISK)
        
        logger.warning(f"Risk event: {self.risk_type} - {self.message}")


class EventQueue:
    """Thread-safe priority queue for managing events."""
    
    def __init__(self):
        self._queue: List[Event] = []
        self._counter = 0
        
    def put(self, event: Event, priority: int = None) -> None:
        """Add event to queue with optional priority override."""
        if priority is not None:
            event.priority = priority
            
        # Use counter to ensure FIFO ordering for events with same priority
        heapq.heappush(self._queue, (event.timestamp, event.priority, self._counter, event))
        self._counter += 1
        
        logger.debug(f"Event queued: {event.event_type.value} for {getattr(event, 'symbol', 'N/A')}")
        
    def get(self) -> Optional[Event]:
        """Get highest priority event from queue."""
        if self._queue:
            _, _, _, event = heapq.heappop(self._queue)
            logger.debug(f"Event dequeued: {event.event_type.value} for {getattr(event, 'symbol', 'N/A')}")
            return event
        return None
        
    def peek(self) -> Optional[Event]:
        """Look at next event without removing it."""
        if self._queue:
            return self._queue[0][3]
        return None
        
    def empty(self) -> bool:
        """Check if queue is empty."""
        return len(self._queue) == 0
        
    def size(self) -> int:
        """Get queue size."""
        return len(self._queue)
        
    def clear(self) -> None:
        """Clear all events from queue."""
        self._queue.clear()
        self._counter = 0
        logger.info("Event queue cleared")


class EventHandler(ABC):
    """Abstract base class for event handlers."""
    
    @abstractmethod
    def handle_event(self, event: Event) -> None:
        """Handle an event."""
        pass
    
    def can_handle(self, event_type: EventType) -> bool:
        """Check if this handler can process the given event type."""
        return True


class EventDispatcher:
    """Event dispatcher that routes events to appropriate handlers."""
    
    def __init__(self):
        self.handlers: Dict[EventType, List[EventHandler]] = {
            event_type: [] for event_type in EventType
        }
        
    def register_handler(self, event_type: EventType, handler: EventHandler) -> None:
        """Register an event handler for a specific event type."""
        self.handlers[event_type].append(handler)
        logger.info(f"Registered handler {handler.__class__.__name__} for {event_type.value} events")
        
    def dispatch(self, event: Event) -> None:
        """Dispatch event to all registered handlers."""
        handlers = self.handlers.get(event.event_type, [])
        
        for handler in handlers:
            try:
                if handler.can_handle(event.event_type):
                    handler.handle_event(event)
            except Exception as e:
                logger.error(f"Error in event handler {handler.__class__.__name__}: {e}")
                
    def remove_handler(self, event_type: EventType, handler: EventHandler) -> None:
        """Remove an event handler."""
        if handler in self.handlers[event_type]:
            self.handlers[event_type].remove(handler)
            logger.info(f"Removed handler {handler.__class__.__name__} for {event_type.value} events")